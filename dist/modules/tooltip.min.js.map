{"version":3,"sources":["tooltip.min.js","tooltip/tooltip.js"],"names":["angular","module","provider","defaults","this","animation","customClass","prefixClass","prefixEvent","container","target","placement","template","contentTemplate","trigger","keyboard","html","show","title","type","delay","$get","$window","$rootScope","$compile","$q","$templateCache","$http","$animate","dimensions","$$rAF","TooltipFactory","element","config","enterAnimateCallback","scope","$emit","options","$tooltip","leaveAnimateCallback","blur","getPosition","offset","position","getCalculatedOffset","actualWidth","actualHeight","split","top","height","left","width","nodeName","toLowerCase","$options","extend","$promise","fetchTemplate","$scope","$new","isString","map","parseFloat","length","hide","$hide","$$postDigest","$show","$toggle","toggle","$isShown","timeout","hoverState","then","templateEl","contentEl","findElement","removeAttr","outerHTML","tipLinker","tipElement","tipTemplate","tipContainer","isObject","data","replace","htmlReplaceRegExp","trim","apply","init","isNumber","isElement","triggers","forEach","on","enter","leave","isTouch","$onFocusElementMouseDown","focus","destroy","i","off","remove","clearTimeout","$destroy","setTimeout","parent","after","$element","clonedElement","css","display","visibility","addClass","promise","$$phase","$root","$digest","$applyPlacement","$onKeyUp","$onFocusKeyUp","elementPosition","tipWidth","prop","tipHeight","tipPosition","evt","which","stopPropagation","preventDefault","query","document","querySelectorAll","when","get","res","put","String","prototype","directive","$location","$sce","restrict","link","attr","transclusion","key","isDefined","$observe","newValue","oldValue","trustAsHtml","tooltip","bsTooltip","$watch","bsShow","match","$on"],"mappings":"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","file":"tooltip.min.js","sourcesContent":["/**\n * angular-strap\n * @version v2.1.0 - 2015-12-14\n * @link http://mgcrea.github.io/angular-strap\n * @author Olivier Louvignes (olivier@mg-crea.com)\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$tooltip', function() {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'tooltip',\r\n      prefixEvent: 'tooltip',\r\n      container: false,\r\n      target: false,\r\n      placement: 'top',\r\n      template: 'tooltip/tooltip.tpl.html',\r\n      contentTemplate: false,\r\n      trigger: 'hover focus',\r\n      keyboard: false,\r\n      html: false,\r\n      show: false,\r\n      title: '',\r\n      type: '',\r\n      delay: 0\r\n    };\r\n\r\n    this.$get = [\"$window\", \"$rootScope\", \"$compile\", \"$q\", \"$templateCache\", \"$http\", \"$animate\", \"dimensions\", \"$$rAF\", function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, dimensions, $$rAF) {\r\n\r\n      var trim = String.prototype.trim;\r\n      var isTouch = 'createTouch' in $window.document;\r\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\r\n\r\n      function TooltipFactory(element, config) {\r\n\r\n        var $tooltip = {};\r\n\r\n        // Common vars\r\n        var nodeName = element[0].nodeName.toLowerCase();\r\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\r\n        $tooltip.$promise = fetchTemplate(options.template);\r\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n        if(options.delay && angular.isString(options.delay)) {\r\n          var split = options.delay.split(',').map(parseFloat);\r\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\r\n        }\r\n\r\n        // Support scope as string options\r\n        if(options.title) {\r\n          $tooltip.$scope.title = options.title;\r\n        }\r\n\r\n        // Provide scope helpers\r\n        scope.$hide = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.hide();\r\n          });\r\n        };\r\n        scope.$show = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.show();\r\n          });\r\n        };\r\n        scope.$toggle = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.toggle();\r\n          });\r\n        };\r\n        $tooltip.$isShown = scope.$isShown = false;\r\n\r\n        // Private vars\r\n        var timeout, hoverState;\r\n\r\n        // Support contentTemplate option\r\n        if(options.contentTemplate) {\r\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\r\n            var templateEl = angular.element(template);\r\n            return fetchTemplate(options.contentTemplate)\r\n            .then(function(contentTemplate) {\r\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\r\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\r\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\r\n              return templateEl[0].outerHTML;\r\n            });\r\n          });\r\n        }\r\n\r\n        // Fetch, compile then initialize tooltip\r\n        var tipLinker, tipElement, tipTemplate, tipContainer;\r\n        $tooltip.$promise.then(function(template) {\r\n          if(angular.isObject(template)) template = template.data;\r\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\r\n          template = trim.apply(template);\r\n          tipTemplate = template;\r\n          tipLinker = $compile(template);\r\n          $tooltip.init();\r\n        });\r\n\r\n        $tooltip.init = function() {\r\n\r\n          // Options: delay\r\n          if (options.delay && angular.isNumber(options.delay)) {\r\n            options.delay = {\r\n              show: options.delay,\r\n              hide: options.delay\r\n            };\r\n          }\r\n\r\n          // Replace trigger on touch devices ?\r\n          // if(isTouch && options.trigger === defaults.trigger) {\r\n          //   options.trigger.replace(/hover/g, 'click');\r\n          // }\r\n\r\n          // Options : container\r\n          if(options.container === 'self') {\r\n            tipContainer = element;\r\n          } else if(angular.isElement(options.container)) {\r\n            tipContainer = options.container;\r\n          } else if(options.container) {\r\n            tipContainer = findElement(options.container);\r\n          }\r\n\r\n          // Options: trigger\r\n          var triggers = options.trigger.split(' ');\r\n          angular.forEach(triggers, function(trigger) {\r\n            if(trigger === 'click') {\r\n              element.on('click', $tooltip.toggle);\r\n            } else if(trigger !== 'manual') {\r\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n            }\r\n          });\r\n\r\n          // Options: target\r\n          if(options.target) {\r\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\r\n          }\r\n\r\n          // Options: show\r\n          if(options.show) {\r\n            scope.$$postDigest(function() {\r\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $tooltip.destroy = function() {\r\n\r\n          // Unbind events\r\n          var triggers = options.trigger.split(' ');\r\n          for (var i = triggers.length; i--;) {\r\n            var trigger = triggers[i];\r\n            if(trigger === 'click') {\r\n              element.off('click', $tooltip.toggle);\r\n            } else if(trigger !== 'manual') {\r\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n            }\r\n          }\r\n\r\n          // Remove element\r\n          if(tipElement) {\r\n            tipElement.remove();\r\n            tipElement = null;\r\n          }\r\n\r\n          // Cancel pending callbacks\r\n          clearTimeout(timeout);\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n\r\n        };\r\n\r\n        $tooltip.enter = function() {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'in';\r\n          if (!options.delay || !options.delay.show) {\r\n            return $tooltip.show();\r\n          }\r\n\r\n          timeout = setTimeout(function() {\r\n            if (hoverState ==='in') $tooltip.show();\r\n          }, options.delay.show);\r\n\r\n        };\r\n\r\n        $tooltip.show = function() {\r\n\r\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\r\n          var parent = options.container ? tipContainer : null;\r\n          var after = options.container ? null : element;\r\n\r\n          // Hide any existing tipElement\r\n          if(tipElement) tipElement.remove();\r\n          // Fetch a cloned element linked from template\r\n          tipElement = $tooltip.$element = tipLinker(scope, function(clonedElement, scope) {});\r\n\r\n          // Set the initial positioning.  Make the tooltip invisible\r\n          // so IE doesn't try to focus on it off screen.\r\n          tipElement.css({top: '-9999px', left: '-9999px', display: 'block', visibility: 'hidden'}).addClass(options.placement);\r\n\r\n          // Options: animation\r\n          if(options.animation) tipElement.addClass(options.animation);\r\n          // Options: type\r\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\r\n          // Options: custom classes\r\n          if(options.customClass) tipElement.addClass(options.customClass);\r\n\r\n          // Support v1.3+ $animate\r\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\r\n          var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);\r\n          if(promise && promise.then) promise.then(enterAnimateCallback);\r\n\r\n          $tooltip.$isShown = scope.$isShown = true;\r\n          scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n          $$rAF(function () {\r\n            $tooltip.$applyPlacement();\r\n\r\n            // Once placed, make the tooltip visible\r\n            if(tipElement)\r\n            tipElement.css({visibility: 'visible'});\r\n          }); // var a = bodyEl.offsetWidth + 1; ?\r\n\r\n          // Bind events\r\n          if(options.keyboard) {\r\n            if(options.trigger !== 'focus') {\r\n              $tooltip.focus();\r\n              tipElement.on('keyup', $tooltip.$onKeyUp);\r\n            } else {\r\n              element.on('keyup', $tooltip.$onFocusKeyUp);\r\n            }\r\n          }\r\n\r\n        };\r\n\r\n        function enterAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\r\n        }\r\n\r\n        $tooltip.leave = function() {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'out';\r\n          if (!options.delay || !options.delay.hide) {\r\n            return $tooltip.hide();\r\n          }\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'out') {\r\n              $tooltip.hide();\r\n            }\r\n          }, options.delay.hide);\r\n\r\n        };\r\n\r\n        $tooltip.hide = function(blur) {\r\n\r\n          if(!$tooltip.$isShown) return;\r\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\r\n\r\n          // Support v1.3+ $animate\r\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\r\n          var promise = $animate.leave(tipElement, leaveAnimateCallback);\r\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\r\n\r\n          $tooltip.$isShown = scope.$isShown = false;\r\n          scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n\r\n          // Unbind events\r\n          if(options.keyboard && tipElement !== null) {\r\n            tipElement.off('keyup', $tooltip.$onKeyUp);\r\n          }\r\n\r\n        };\r\n\r\n        function leaveAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\r\n          // Allow to blur the input when hidden, like when pressing enter key\r\n          if(blur && options.trigger === 'focus') {\r\n            return element[0].blur();\r\n          }\r\n        }\r\n\r\n        $tooltip.toggle = function() {\r\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\r\n        };\r\n\r\n        $tooltip.focus = function() {\r\n          tipElement[0].focus();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $tooltip.$applyPlacement = function() {\r\n          if(!tipElement) return;\r\n\r\n          // Get the position of the tooltip element.\r\n          var elementPosition = getPosition();\r\n\r\n          // Get the height and width of the tooltip so we can center it.\r\n          var tipWidth = tipElement.prop('offsetWidth'),\r\n              tipHeight = tipElement.prop('offsetHeight');\r\n\r\n          // Get the tooltip's top and left coordinates to center it with this directive.\r\n          var tipPosition = getCalculatedOffset(options.placement, elementPosition, tipWidth, tipHeight);\r\n\r\n          // Now set the calculated positioning.\r\n          tipPosition.top += 'px';\r\n          tipPosition.left += 'px';\r\n          tipElement.css(tipPosition);\r\n\r\n        };\r\n\r\n        $tooltip.$onKeyUp = function(evt) {\r\n          if (evt.which === 27 && $tooltip.$isShown) {\r\n            $tooltip.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusKeyUp = function(evt) {\r\n          if (evt.which === 27) {\r\n            element[0].blur();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusElementMouseDown = function(evt) {\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Some browsers do not auto-focus buttons (eg. Safari)\r\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\r\n        };\r\n\r\n        // Private methods\r\n\r\n        function getPosition() {\r\n          if(options.container === 'body') {\r\n            return dimensions.offset(options.target[0] || element[0]);\r\n          } else {\r\n            return dimensions.position(options.target[0] || element[0]);\r\n          }\r\n        }\r\n\r\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\r\n          var offset;\r\n          var split = placement.split('-');\r\n\r\n          switch (split[0]) {\r\n          case 'right':\r\n            offset = {\r\n              top: position.top + position.height / 2 - actualHeight / 2,\r\n              left: position.left + position.width\r\n            };\r\n            break;\r\n          case 'bottom':\r\n            offset = {\r\n              top: position.top + position.height,\r\n              left: position.left + position.width / 2 - actualWidth / 2\r\n            };\r\n            break;\r\n          case 'left':\r\n            offset = {\r\n              top: position.top + position.height / 2 - actualHeight / 2,\r\n              left: position.left - actualWidth\r\n            };\r\n            break;\r\n          default:\r\n            offset = {\r\n              top: position.top - actualHeight,\r\n              left: position.left + position.width / 2 - actualWidth / 2\r\n            };\r\n            break;\r\n          }\r\n\r\n          if(!split[1]) {\r\n            return offset;\r\n          }\r\n\r\n          // Add support for corners @todo css\r\n          if(split[0] === 'top' || split[0] === 'bottom') {\r\n            switch (split[1]) {\r\n            case 'left':\r\n              offset.left = position.left;\r\n              break;\r\n            case 'right':\r\n              offset.left =  position.left + position.width - actualWidth;\r\n            }\r\n          } else if(split[0] === 'left' || split[0] === 'right') {\r\n            switch (split[1]) {\r\n            case 'top':\r\n              offset.top = position.top - actualHeight;\r\n              break;\r\n            case 'bottom':\r\n              offset.top = position.top + position.height;\r\n            }\r\n          }\r\n\r\n          return offset;\r\n        }\r\n\r\n        return $tooltip;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function findElement(query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      function fetchTemplate(template) {\r\n        return $q.when($templateCache.get(template) || $http.get(template))\r\n        .then(function(res) {\r\n          if(angular.isObject(res)) {\r\n            $templateCache.put(template, res.data);\r\n            return res.data;\r\n          }\r\n          return res;\r\n        });\r\n      }\r\n\r\n      return TooltipFactory;\r\n\r\n    }];\r\n\r\n  })\r\n\r\n  .directive('bsTooltip', [\"$window\", \"$location\", \"$sce\", \"$tooltip\", \"$$rAF\", function($window, $location, $sce, $tooltip, $$rAF) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink(scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'target', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'type', 'customClass'], function(key) {\r\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Observe scope attributes for change\r\n        attr.$observe('title', function(newValue, oldValue) {\r\n          scope.title = $sce.trustAsHtml(newValue);\r\n          angular.isDefined(oldValue) && $$rAF(function() {\r\n            tooltip && tooltip.$applyPlacement();\r\n          });\r\n        });\r\n\r\n        // Support scope as an object\r\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\r\n          if(angular.isObject(newValue)) {\r\n            angular.extend(scope, newValue);\r\n          } else {\r\n            scope.title = newValue;\r\n          }\r\n          angular.isDefined(oldValue) && $$rAF(function() {\r\n            tooltip && tooltip.$applyPlacement();\r\n          });\r\n        }, true);\r\n\r\n        // Visibility binding support\r\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\r\n          if(!tooltip || !angular.isDefined(newValue)) return;\r\n          if(angular.isString(newValue)) newValue = !!newValue.match(',?(tooltip),?');\r\n          newValue === true ? tooltip.show() : tooltip.hide();\r\n        });\r\n\r\n        // Initialize popover\r\n        var tooltip = $tooltip(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function() {\r\n          if(tooltip) tooltip.destroy();\r\n          options = null;\r\n          tooltip = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  }]);\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\r\n\r\n  .provider('$tooltip', function() {\r\n\r\n    var defaults = this.defaults = {\r\n      animation: 'am-fade',\r\n      customClass: '',\r\n      prefixClass: 'tooltip',\r\n      prefixEvent: 'tooltip',\r\n      container: false,\r\n      target: false,\r\n      placement: 'top',\r\n      template: 'tooltip/tooltip.tpl.html',\r\n      contentTemplate: false,\r\n      trigger: 'hover focus',\r\n      keyboard: false,\r\n      html: false,\r\n      show: false,\r\n      title: '',\r\n      type: '',\r\n      delay: 0\r\n    };\r\n\r\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, dimensions, $$rAF) {\r\n\r\n      var trim = String.prototype.trim;\r\n      var isTouch = 'createTouch' in $window.document;\r\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\r\n\r\n      function TooltipFactory(element, config) {\r\n\r\n        var $tooltip = {};\r\n\r\n        // Common vars\r\n        var nodeName = element[0].nodeName.toLowerCase();\r\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\r\n        $tooltip.$promise = fetchTemplate(options.template);\r\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\r\n        if(options.delay && angular.isString(options.delay)) {\r\n          var split = options.delay.split(',').map(parseFloat);\r\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\r\n        }\r\n\r\n        // Support scope as string options\r\n        if(options.title) {\r\n          $tooltip.$scope.title = options.title;\r\n        }\r\n\r\n        // Provide scope helpers\r\n        scope.$hide = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.hide();\r\n          });\r\n        };\r\n        scope.$show = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.show();\r\n          });\r\n        };\r\n        scope.$toggle = function() {\r\n          scope.$$postDigest(function() {\r\n            $tooltip.toggle();\r\n          });\r\n        };\r\n        $tooltip.$isShown = scope.$isShown = false;\r\n\r\n        // Private vars\r\n        var timeout, hoverState;\r\n\r\n        // Support contentTemplate option\r\n        if(options.contentTemplate) {\r\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\r\n            var templateEl = angular.element(template);\r\n            return fetchTemplate(options.contentTemplate)\r\n            .then(function(contentTemplate) {\r\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\r\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\r\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\r\n              return templateEl[0].outerHTML;\r\n            });\r\n          });\r\n        }\r\n\r\n        // Fetch, compile then initialize tooltip\r\n        var tipLinker, tipElement, tipTemplate, tipContainer;\r\n        $tooltip.$promise.then(function(template) {\r\n          if(angular.isObject(template)) template = template.data;\r\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\r\n          template = trim.apply(template);\r\n          tipTemplate = template;\r\n          tipLinker = $compile(template);\r\n          $tooltip.init();\r\n        });\r\n\r\n        $tooltip.init = function() {\r\n\r\n          // Options: delay\r\n          if (options.delay && angular.isNumber(options.delay)) {\r\n            options.delay = {\r\n              show: options.delay,\r\n              hide: options.delay\r\n            };\r\n          }\r\n\r\n          // Replace trigger on touch devices ?\r\n          // if(isTouch && options.trigger === defaults.trigger) {\r\n          //   options.trigger.replace(/hover/g, 'click');\r\n          // }\r\n\r\n          // Options : container\r\n          if(options.container === 'self') {\r\n            tipContainer = element;\r\n          } else if(angular.isElement(options.container)) {\r\n            tipContainer = options.container;\r\n          } else if(options.container) {\r\n            tipContainer = findElement(options.container);\r\n          }\r\n\r\n          // Options: trigger\r\n          var triggers = options.trigger.split(' ');\r\n          angular.forEach(triggers, function(trigger) {\r\n            if(trigger === 'click') {\r\n              element.on('click', $tooltip.toggle);\r\n            } else if(trigger !== 'manual') {\r\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n            }\r\n          });\r\n\r\n          // Options: target\r\n          if(options.target) {\r\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\r\n          }\r\n\r\n          // Options: show\r\n          if(options.show) {\r\n            scope.$$postDigest(function() {\r\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\r\n            });\r\n          }\r\n\r\n        };\r\n\r\n        $tooltip.destroy = function() {\r\n\r\n          // Unbind events\r\n          var triggers = options.trigger.split(' ');\r\n          for (var i = triggers.length; i--;) {\r\n            var trigger = triggers[i];\r\n            if(trigger === 'click') {\r\n              element.off('click', $tooltip.toggle);\r\n            } else if(trigger !== 'manual') {\r\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\r\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\r\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\r\n            }\r\n          }\r\n\r\n          // Remove element\r\n          if(tipElement) {\r\n            tipElement.remove();\r\n            tipElement = null;\r\n          }\r\n\r\n          // Cancel pending callbacks\r\n          clearTimeout(timeout);\r\n\r\n          // Destroy scope\r\n          scope.$destroy();\r\n\r\n        };\r\n\r\n        $tooltip.enter = function() {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'in';\r\n          if (!options.delay || !options.delay.show) {\r\n            return $tooltip.show();\r\n          }\r\n\r\n          timeout = setTimeout(function() {\r\n            if (hoverState ==='in') $tooltip.show();\r\n          }, options.delay.show);\r\n\r\n        };\r\n\r\n        $tooltip.show = function() {\r\n\r\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\r\n          var parent = options.container ? tipContainer : null;\r\n          var after = options.container ? null : element;\r\n\r\n          // Hide any existing tipElement\r\n          if(tipElement) tipElement.remove();\r\n          // Fetch a cloned element linked from template\r\n          tipElement = $tooltip.$element = tipLinker(scope, function(clonedElement, scope) {});\r\n\r\n          // Set the initial positioning.  Make the tooltip invisible\r\n          // so IE doesn't try to focus on it off screen.\r\n          tipElement.css({top: '-9999px', left: '-9999px', display: 'block', visibility: 'hidden'}).addClass(options.placement);\r\n\r\n          // Options: animation\r\n          if(options.animation) tipElement.addClass(options.animation);\r\n          // Options: type\r\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\r\n          // Options: custom classes\r\n          if(options.customClass) tipElement.addClass(options.customClass);\r\n\r\n          // Support v1.3+ $animate\r\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\r\n          var promise = $animate.enter(tipElement, parent, after, enterAnimateCallback);\r\n          if(promise && promise.then) promise.then(enterAnimateCallback);\r\n\r\n          $tooltip.$isShown = scope.$isShown = true;\r\n          scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n          $$rAF(function () {\r\n            $tooltip.$applyPlacement();\r\n\r\n            // Once placed, make the tooltip visible\r\n            if(tipElement)\r\n            tipElement.css({visibility: 'visible'});\r\n          }); // var a = bodyEl.offsetWidth + 1; ?\r\n\r\n          // Bind events\r\n          if(options.keyboard) {\r\n            if(options.trigger !== 'focus') {\r\n              $tooltip.focus();\r\n              tipElement.on('keyup', $tooltip.$onKeyUp);\r\n            } else {\r\n              element.on('keyup', $tooltip.$onFocusKeyUp);\r\n            }\r\n          }\r\n\r\n        };\r\n\r\n        function enterAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\r\n        }\r\n\r\n        $tooltip.leave = function() {\r\n\r\n          clearTimeout(timeout);\r\n          hoverState = 'out';\r\n          if (!options.delay || !options.delay.hide) {\r\n            return $tooltip.hide();\r\n          }\r\n          timeout = setTimeout(function () {\r\n            if (hoverState === 'out') {\r\n              $tooltip.hide();\r\n            }\r\n          }, options.delay.hide);\r\n\r\n        };\r\n\r\n        $tooltip.hide = function(blur) {\r\n\r\n          if(!$tooltip.$isShown) return;\r\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\r\n\r\n          // Support v1.3+ $animate\r\n          // https://github.com/angular/angular.js/commit/bf0f5502b1bbfddc5cdd2f138efd9188b8c652a9\r\n          var promise = $animate.leave(tipElement, leaveAnimateCallback);\r\n          if(promise && promise.then) promise.then(leaveAnimateCallback);\r\n\r\n          $tooltip.$isShown = scope.$isShown = false;\r\n          scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\r\n\r\n          // Unbind events\r\n          if(options.keyboard && tipElement !== null) {\r\n            tipElement.off('keyup', $tooltip.$onKeyUp);\r\n          }\r\n\r\n        };\r\n\r\n        function leaveAnimateCallback() {\r\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\r\n          // Allow to blur the input when hidden, like when pressing enter key\r\n          if(blur && options.trigger === 'focus') {\r\n            return element[0].blur();\r\n          }\r\n        }\r\n\r\n        $tooltip.toggle = function() {\r\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\r\n        };\r\n\r\n        $tooltip.focus = function() {\r\n          tipElement[0].focus();\r\n        };\r\n\r\n        // Protected methods\r\n\r\n        $tooltip.$applyPlacement = function() {\r\n          if(!tipElement) return;\r\n\r\n          // Get the position of the tooltip element.\r\n          var elementPosition = getPosition();\r\n\r\n          // Get the height and width of the tooltip so we can center it.\r\n          var tipWidth = tipElement.prop('offsetWidth'),\r\n              tipHeight = tipElement.prop('offsetHeight');\r\n\r\n          // Get the tooltip's top and left coordinates to center it with this directive.\r\n          var tipPosition = getCalculatedOffset(options.placement, elementPosition, tipWidth, tipHeight);\r\n\r\n          // Now set the calculated positioning.\r\n          tipPosition.top += 'px';\r\n          tipPosition.left += 'px';\r\n          tipElement.css(tipPosition);\r\n\r\n        };\r\n\r\n        $tooltip.$onKeyUp = function(evt) {\r\n          if (evt.which === 27 && $tooltip.$isShown) {\r\n            $tooltip.hide();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusKeyUp = function(evt) {\r\n          if (evt.which === 27) {\r\n            element[0].blur();\r\n            evt.stopPropagation();\r\n          }\r\n        };\r\n\r\n        $tooltip.$onFocusElementMouseDown = function(evt) {\r\n          evt.preventDefault();\r\n          evt.stopPropagation();\r\n          // Some browsers do not auto-focus buttons (eg. Safari)\r\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\r\n        };\r\n\r\n        // Private methods\r\n\r\n        function getPosition() {\r\n          if(options.container === 'body') {\r\n            return dimensions.offset(options.target[0] || element[0]);\r\n          } else {\r\n            return dimensions.position(options.target[0] || element[0]);\r\n          }\r\n        }\r\n\r\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\r\n          var offset;\r\n          var split = placement.split('-');\r\n\r\n          switch (split[0]) {\r\n          case 'right':\r\n            offset = {\r\n              top: position.top + position.height / 2 - actualHeight / 2,\r\n              left: position.left + position.width\r\n            };\r\n            break;\r\n          case 'bottom':\r\n            offset = {\r\n              top: position.top + position.height,\r\n              left: position.left + position.width / 2 - actualWidth / 2\r\n            };\r\n            break;\r\n          case 'left':\r\n            offset = {\r\n              top: position.top + position.height / 2 - actualHeight / 2,\r\n              left: position.left - actualWidth\r\n            };\r\n            break;\r\n          default:\r\n            offset = {\r\n              top: position.top - actualHeight,\r\n              left: position.left + position.width / 2 - actualWidth / 2\r\n            };\r\n            break;\r\n          }\r\n\r\n          if(!split[1]) {\r\n            return offset;\r\n          }\r\n\r\n          // Add support for corners @todo css\r\n          if(split[0] === 'top' || split[0] === 'bottom') {\r\n            switch (split[1]) {\r\n            case 'left':\r\n              offset.left = position.left;\r\n              break;\r\n            case 'right':\r\n              offset.left =  position.left + position.width - actualWidth;\r\n            }\r\n          } else if(split[0] === 'left' || split[0] === 'right') {\r\n            switch (split[1]) {\r\n            case 'top':\r\n              offset.top = position.top - actualHeight;\r\n              break;\r\n            case 'bottom':\r\n              offset.top = position.top + position.height;\r\n            }\r\n          }\r\n\r\n          return offset;\r\n        }\r\n\r\n        return $tooltip;\r\n\r\n      }\r\n\r\n      // Helper functions\r\n\r\n      function findElement(query, element) {\r\n        return angular.element((element || document).querySelectorAll(query));\r\n      }\r\n\r\n      function fetchTemplate(template) {\r\n        return $q.when($templateCache.get(template) || $http.get(template))\r\n        .then(function(res) {\r\n          if(angular.isObject(res)) {\r\n            $templateCache.put(template, res.data);\r\n            return res.data;\r\n          }\r\n          return res;\r\n        });\r\n      }\r\n\r\n      return TooltipFactory;\r\n\r\n    };\r\n\r\n  })\r\n\r\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\r\n\r\n    return {\r\n      restrict: 'EAC',\r\n      scope: true,\r\n      link: function postLink(scope, element, attr, transclusion) {\r\n\r\n        // Directive options\r\n        var options = {scope: scope};\r\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'target', 'delay', 'trigger', 'keyboard', 'html', 'animation', 'type', 'customClass'], function(key) {\r\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\r\n        });\r\n\r\n        // Observe scope attributes for change\r\n        attr.$observe('title', function(newValue, oldValue) {\r\n          scope.title = $sce.trustAsHtml(newValue);\r\n          angular.isDefined(oldValue) && $$rAF(function() {\r\n            tooltip && tooltip.$applyPlacement();\r\n          });\r\n        });\r\n\r\n        // Support scope as an object\r\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\r\n          if(angular.isObject(newValue)) {\r\n            angular.extend(scope, newValue);\r\n          } else {\r\n            scope.title = newValue;\r\n          }\r\n          angular.isDefined(oldValue) && $$rAF(function() {\r\n            tooltip && tooltip.$applyPlacement();\r\n          });\r\n        }, true);\r\n\r\n        // Visibility binding support\r\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\r\n          if(!tooltip || !angular.isDefined(newValue)) return;\r\n          if(angular.isString(newValue)) newValue = !!newValue.match(',?(tooltip),?');\r\n          newValue === true ? tooltip.show() : tooltip.hide();\r\n        });\r\n\r\n        // Initialize popover\r\n        var tooltip = $tooltip(element, options);\r\n\r\n        // Garbage collection\r\n        scope.$on('$destroy', function() {\r\n          if(tooltip) tooltip.destroy();\r\n          options = null;\r\n          tooltip = null;\r\n        });\r\n\r\n      }\r\n    };\r\n\r\n  });\r\n"],"sourceRoot":"/source/"}