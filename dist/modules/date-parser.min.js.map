{"version":3,"sources":["date-parser.min.js","helpers/date-parser.js"],"names":["angular","module","provider","$localeProvider","noop","proto","Date","prototype","defaults","this","format","strict","$get","$locale","dateFilter","DateParserFactory","config","setMapForFormat","i","keys","Object","setFnMap","map","sortedMap","clonedFormat","length","split","index","search","join","forEach","v","push","escapeReservedSymbols","text","replace","regExpForFormat","regExpMap","re","RegExp","regex","setMap","options","extend","$dateParser","sss","ss","s","mm","m","HH","H","hh","h","a","EEEE","DATETIME_FORMATS","DAY","EEE","SHORTDAY","dd","d","MMMM","MONTH","MMM","SHORTMONTH","MM","M","yyyy","yy","y","setMilliseconds","setSeconds","setMinutes","setHours","setDate","value","hours","getHours","match","setMonth","indexOf","setFullYear","init","$format","isValid","date","isDate","isNaN","getTime","test","parse","baseDate","formatRegex","formatSetMap","matches","exec","call"],"mappings":"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","file":"date-parser.min.js","sourcesContent":["/**\n * angular-strap\n * @version v2.1.0 - 2015-12-14\n * @link http://mgcrea.github.io/angular-strap\n * @author Olivier Louvignes (olivier@mg-crea.com)\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\r\n\r\n.provider('$dateParser', [\"$localeProvider\", function($localeProvider) {\r\n\r\n  var proto = Date.prototype;\r\n\r\n  function noop() {\r\n  }\r\n\r\n  function isNumeric(n) {\r\n    return !isNaN(parseFloat(n)) && isFinite(n);\r\n  }\r\n\r\n  var defaults = this.defaults = {\r\n    format: 'shortDate',\r\n    strict: false\r\n  };\r\n\r\n  this.$get = [\"$locale\", \"dateFilter\", function($locale, dateFilter) {\r\n\r\n    var DateParserFactory = function(config) {\r\n\r\n      var options = angular.extend({}, defaults, config);\r\n\r\n      var $dateParser = {};\r\n\r\n      var regExpMap = {\r\n        'sss'   : '[0-9]{3}',\r\n        'ss'    : '[0-5][0-9]',\r\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'mm'    : '[0-5][0-9]',\r\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'HH'    : '[01][0-9]|2[0-3]',\r\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\r\n        'hh'    : '[0][1-9]|[1][012]',\r\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'a'     : 'AM|PM',\r\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\r\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\r\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\r\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\r\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\r\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\r\n        'MM'    : '0[1-9]|1[012]',\r\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\r\n        'yy'    : '[0-9]{2}',\r\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}',\r\n      };\r\n\r\n      var setFnMap = {\r\n        'sss'   : proto.setMilliseconds,\r\n        'ss'    : proto.setSeconds,\r\n        's'     : proto.setSeconds,\r\n        'mm'    : proto.setMinutes,\r\n        'm'     : proto.setMinutes,\r\n        'HH'    : proto.setHours,\r\n        'H'     : proto.setHours,\r\n        'hh'    : proto.setHours,\r\n        'h'     : proto.setHours,\r\n        'EEEE'  : noop,\r\n        'EEE'   : noop,\r\n        'dd'    : proto.setDate,\r\n        'd'     : proto.setDate,\r\n        'a'     : function(value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\r\n        'MMMM'  : function(value) { return this.setMonth($locale.DATETIME_FORMATS.MONTH.indexOf(value)); },\r\n        'MMM'   : function(value) { return this.setMonth($locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value)); },\r\n        'MM'    : function(value) { return this.setMonth(1 * value - 1); },\r\n        'M'     : function(value) { return this.setMonth(1 * value - 1); },\r\n        'yyyy'  : proto.setFullYear,\r\n        'yy'    : function(value) { return this.setFullYear(2000 + 1 * value); },\r\n        'y'     : proto.setFullYear\r\n      };\r\n\r\n      var regex, setMap;\r\n\r\n      $dateParser.init = function() {\r\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\r\n        regex = regExpForFormat($dateParser.$format);\r\n        setMap = setMapForFormat($dateParser.$format);\r\n      };\r\n\r\n      $dateParser.isValid = function(date) {\r\n        if(angular.isDate(date)) return !isNaN(date.getTime());\r\n        return regex.test(date);\r\n      };\r\n\r\n      $dateParser.parse = function(value, baseDate, format) {\r\n        if(angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format);\r\n        var formatRegex = format ? regExpForFormat(format) : regex;\r\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\r\n        var matches = formatRegex.exec(value);\r\n        if(!matches) return false;\r\n        var date = baseDate || new Date(0, 0, 1);\r\n        for(var i = 0; i < matches.length - 1; i++) {\r\n          formatSetMap[i] && formatSetMap[i].call(date, matches[i+1]);\r\n        }\r\n        return date;\r\n      };\r\n\r\n      // Private functions\r\n\r\n      function setMapForFormat(format) {\r\n        var keys = Object.keys(setFnMap), i;\r\n        var map = [], sortedMap = [];\r\n        // Map to setFn\r\n        var clonedFormat = format;\r\n        for(i = 0; i < keys.length; i++) {\r\n          if(format.split(keys[i]).length > 1) {\r\n            var index = clonedFormat.search(keys[i]);\r\n            format = format.split(keys[i]).join('');\r\n            if(setFnMap[keys[i]]) {\r\n              map[index] = setFnMap[keys[i]];\r\n            }\r\n          }\r\n        }\r\n        // Sort result map\r\n        angular.forEach(map, function(v) {\r\n          // conditional required since angular.forEach broke around v1.2.21\r\n          // related pr: https://github.com/angular/angular.js/pull/8525\r\n          if(v) sortedMap.push(v);\r\n        });\r\n        return sortedMap;\r\n      }\r\n\r\n      function escapeReservedSymbols(text) {\r\n        return text.replace(/\\//g, '[\\\\/]').replace('/-/g', '[-]').replace(/\\./g, '[.]').replace(/\\\\s/g, '[\\\\s]');\r\n      }\r\n\r\n      function regExpForFormat(format) {\r\n        var keys = Object.keys(regExpMap), i;\r\n\r\n        var re = format;\r\n        // Abstract replaces to avoid collisions\r\n        for(i = 0; i < keys.length; i++) {\r\n          re = re.split(keys[i]).join('${' + i + '}');\r\n        }\r\n        // Replace abstracted values\r\n        for(i = 0; i < keys.length; i++) {\r\n          re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');\r\n        }\r\n        format = escapeReservedSymbols(format);\r\n\r\n        return new RegExp('^' + re + '$', ['i']);\r\n      }\r\n\r\n      $dateParser.init();\r\n      return $dateParser;\r\n\r\n    };\r\n\r\n    return DateParserFactory;\r\n\r\n  }];\r\n\r\n}]);\r\n","'use strict';\r\n\r\nangular.module('mgcrea.ngStrap.helpers.dateParser', [])\r\n\r\n.provider('$dateParser', function($localeProvider) {\r\n\r\n  var proto = Date.prototype;\r\n\r\n  function noop() {\r\n  }\r\n\r\n  function isNumeric(n) {\r\n    return !isNaN(parseFloat(n)) && isFinite(n);\r\n  }\r\n\r\n  var defaults = this.defaults = {\r\n    format: 'shortDate',\r\n    strict: false\r\n  };\r\n\r\n  this.$get = function($locale, dateFilter) {\r\n\r\n    var DateParserFactory = function(config) {\r\n\r\n      var options = angular.extend({}, defaults, config);\r\n\r\n      var $dateParser = {};\r\n\r\n      var regExpMap = {\r\n        'sss'   : '[0-9]{3}',\r\n        'ss'    : '[0-5][0-9]',\r\n        's'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'mm'    : '[0-5][0-9]',\r\n        'm'     : options.strict ? '[1-5]?[0-9]' : '[0-9]|[0-5][0-9]',\r\n        'HH'    : '[01][0-9]|2[0-3]',\r\n        'H'     : options.strict ? '1?[0-9]|2[0-3]' : '[01]?[0-9]|2[0-3]',\r\n        'hh'    : '[0][1-9]|[1][012]',\r\n        'h'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'a'     : 'AM|PM',\r\n        'EEEE'  : $locale.DATETIME_FORMATS.DAY.join('|'),\r\n        'EEE'   : $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\r\n        'dd'    : '0[1-9]|[12][0-9]|3[01]',\r\n        'd'     : options.strict ? '[1-9]|[1-2][0-9]|3[01]' : '0?[1-9]|[1-2][0-9]|3[01]',\r\n        'MMMM'  : $locale.DATETIME_FORMATS.MONTH.join('|'),\r\n        'MMM'   : $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\r\n        'MM'    : '0[1-9]|1[012]',\r\n        'M'     : options.strict ? '[1-9]|1[012]' : '0?[1-9]|1[012]',\r\n        'yyyy'  : '[1]{1}[0-9]{3}|[2]{1}[0-9]{3}',\r\n        'yy'    : '[0-9]{2}',\r\n        'y'     : options.strict ? '-?(0|[1-9][0-9]{0,3})' : '-?0*[0-9]{1,4}',\r\n      };\r\n\r\n      var setFnMap = {\r\n        'sss'   : proto.setMilliseconds,\r\n        'ss'    : proto.setSeconds,\r\n        's'     : proto.setSeconds,\r\n        'mm'    : proto.setMinutes,\r\n        'm'     : proto.setMinutes,\r\n        'HH'    : proto.setHours,\r\n        'H'     : proto.setHours,\r\n        'hh'    : proto.setHours,\r\n        'h'     : proto.setHours,\r\n        'EEEE'  : noop,\r\n        'EEE'   : noop,\r\n        'dd'    : proto.setDate,\r\n        'd'     : proto.setDate,\r\n        'a'     : function(value) { var hours = this.getHours() % 12; return this.setHours(value.match(/pm/i) ? hours + 12 : hours); },\r\n        'MMMM'  : function(value) { return this.setMonth($locale.DATETIME_FORMATS.MONTH.indexOf(value)); },\r\n        'MMM'   : function(value) { return this.setMonth($locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value)); },\r\n        'MM'    : function(value) { return this.setMonth(1 * value - 1); },\r\n        'M'     : function(value) { return this.setMonth(1 * value - 1); },\r\n        'yyyy'  : proto.setFullYear,\r\n        'yy'    : function(value) { return this.setFullYear(2000 + 1 * value); },\r\n        'y'     : proto.setFullYear\r\n      };\r\n\r\n      var regex, setMap;\r\n\r\n      $dateParser.init = function() {\r\n        $dateParser.$format = $locale.DATETIME_FORMATS[options.format] || options.format;\r\n        regex = regExpForFormat($dateParser.$format);\r\n        setMap = setMapForFormat($dateParser.$format);\r\n      };\r\n\r\n      $dateParser.isValid = function(date) {\r\n        if(angular.isDate(date)) return !isNaN(date.getTime());\r\n        return regex.test(date);\r\n      };\r\n\r\n      $dateParser.parse = function(value, baseDate, format) {\r\n        if(angular.isDate(value)) value = dateFilter(value, format || $dateParser.$format);\r\n        var formatRegex = format ? regExpForFormat(format) : regex;\r\n        var formatSetMap = format ? setMapForFormat(format) : setMap;\r\n        var matches = formatRegex.exec(value);\r\n        if(!matches) return false;\r\n        var date = baseDate || new Date(0, 0, 1);\r\n        for(var i = 0; i < matches.length - 1; i++) {\r\n          formatSetMap[i] && formatSetMap[i].call(date, matches[i+1]);\r\n        }\r\n        return date;\r\n      };\r\n\r\n      // Private functions\r\n\r\n      function setMapForFormat(format) {\r\n        var keys = Object.keys(setFnMap), i;\r\n        var map = [], sortedMap = [];\r\n        // Map to setFn\r\n        var clonedFormat = format;\r\n        for(i = 0; i < keys.length; i++) {\r\n          if(format.split(keys[i]).length > 1) {\r\n            var index = clonedFormat.search(keys[i]);\r\n            format = format.split(keys[i]).join('');\r\n            if(setFnMap[keys[i]]) {\r\n              map[index] = setFnMap[keys[i]];\r\n            }\r\n          }\r\n        }\r\n        // Sort result map\r\n        angular.forEach(map, function(v) {\r\n          // conditional required since angular.forEach broke around v1.2.21\r\n          // related pr: https://github.com/angular/angular.js/pull/8525\r\n          if(v) sortedMap.push(v);\r\n        });\r\n        return sortedMap;\r\n      }\r\n\r\n      function escapeReservedSymbols(text) {\r\n        return text.replace(/\\//g, '[\\\\/]').replace('/-/g', '[-]').replace(/\\./g, '[.]').replace(/\\\\s/g, '[\\\\s]');\r\n      }\r\n\r\n      function regExpForFormat(format) {\r\n        var keys = Object.keys(regExpMap), i;\r\n\r\n        var re = format;\r\n        // Abstract replaces to avoid collisions\r\n        for(i = 0; i < keys.length; i++) {\r\n          re = re.split(keys[i]).join('${' + i + '}');\r\n        }\r\n        // Replace abstracted values\r\n        for(i = 0; i < keys.length; i++) {\r\n          re = re.split('${' + i + '}').join('(' + regExpMap[keys[i]] + ')');\r\n        }\r\n        format = escapeReservedSymbols(format);\r\n\r\n        return new RegExp('^' + re + '$', ['i']);\r\n      }\r\n\r\n      $dateParser.init();\r\n      return $dateParser;\r\n\r\n    };\r\n\r\n    return DateParserFactory;\r\n\r\n  };\r\n\r\n});\r\n"],"sourceRoot":"/source/"}